import{e as t}from"./vendor-CMABA041.js";function e(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var s,r;"function"==typeof SuppressedError&&SuppressedError;var i=e(r?s:(r=1,s=function t(e,s){if(e===s)return!0;if(e&&s&&"object"==typeof e&&"object"==typeof s){if(e.constructor!==s.constructor)return!1;var r,i,o;if(Array.isArray(e)){if((r=e.length)!=s.length)return!1;for(i=r;0!==i--;)if(!t(e[i],s[i]))return!1;return!0}if(e.constructor===RegExp)return e.source===s.source&&e.flags===s.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===s.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===s.toString();if((r=(o=Object.keys(e)).length)!==Object.keys(s).length)return!1;for(i=r;0!==i--;)if(!Object.prototype.hasOwnProperty.call(s,o[i]))return!1;for(i=r;0!==i--;){var n=o[i];if(!t(e[n],s[n]))return!1}return!0}return e!=e&&s!=s}));const o="__googleMapsScriptId";var n,a;(a=n||(n={}))[a.INITIALIZED=0]="INITIALIZED",a[a.LOADING=1]="LOADING",a[a.SUCCESS=2]="SUCCESS",a[a.FAILURE=3]="FAILURE";class h{constructor({apiKey:t,authReferrerPolicy:e,channel:s,client:r,id:n=o,language:a,libraries:l=[],mapIds:c,nonce:u,region:p,retries:d=3,url:m="https://maps.googleapis.com/maps/api/js",version:g}){if(this.callbacks=[],this.done=!1,this.loading=!1,this.errors=[],this.apiKey=t,this.authReferrerPolicy=e,this.channel=s,this.client=r,this.id=n||o,this.language=a,this.libraries=l,this.mapIds=c,this.nonce=u,this.region=p,this.retries=d,this.url=m,this.version=g,h.instance){if(!i(this.options,h.instance.options))throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(h.instance.options)}`);return h.instance}h.instance=this}get options(){return{version:this.version,apiKey:this.apiKey,channel:this.channel,client:this.client,id:this.id,libraries:this.libraries,language:this.language,region:this.region,mapIds:this.mapIds,nonce:this.nonce,url:this.url,authReferrerPolicy:this.authReferrerPolicy}}get status(){return this.errors.length?n.FAILURE:this.done?n.SUCCESS:this.loading?n.LOADING:n.INITIALIZED}get failed(){return this.done&&!this.loading&&this.errors.length>=this.retries+1}createUrl(){let t=this.url;return t+="?callback=__googleMapsCallback&loading=async",this.apiKey&&(t+=`&key=${this.apiKey}`),this.channel&&(t+=`&channel=${this.channel}`),this.client&&(t+=`&client=${this.client}`),this.libraries.length>0&&(t+=`&libraries=${this.libraries.join(",")}`),this.language&&(t+=`&language=${this.language}`),this.region&&(t+=`&region=${this.region}`),this.version&&(t+=`&v=${this.version}`),this.mapIds&&(t+=`&map_ids=${this.mapIds.join(",")}`),this.authReferrerPolicy&&(t+=`&auth_referrer_policy=${this.authReferrerPolicy}`),t}deleteScript(){const t=document.getElementById(this.id);t&&t.remove()}load(){return this.loadPromise()}loadPromise(){return new Promise((t,e)=>{this.loadCallback(s=>{s?e(s.error):t(window.google)})})}importLibrary(t){return this.execute(),google.maps.importLibrary(t)}loadCallback(t){this.callbacks.push(t),this.execute()}setScript(){var t,e;if(document.getElementById(this.id))return void this.callback();const s={key:this.apiKey,channel:this.channel,client:this.client,libraries:this.libraries.length&&this.libraries,v:this.version,mapIds:this.mapIds,language:this.language,region:this.region,authReferrerPolicy:this.authReferrerPolicy};Object.keys(s).forEach(t=>!s[t]&&delete s[t]),(null===(e=null===(t=null===window||void 0===window?void 0:window.google)||void 0===t?void 0:t.maps)||void 0===e?void 0:e.importLibrary)||(t=>{let e,s,r,i="The Google Maps JavaScript API",o="google",n="importLibrary",a="__ib__",h=document,l=window;l=l[o]||(l[o]={});const c=l.maps||(l.maps={}),u=new Set,p=new URLSearchParams,d=()=>e||(e=new Promise((n,l)=>{return d=this,m=void 0,f=function*(){var d;for(r in yield s=h.createElement("script"),s.id=this.id,p.set("libraries",[...u]+""),t)p.set(r.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),t[r]);p.set("callback",o+".maps."+a),s.src=this.url+"?"+p,c[a]=n,s.onerror=()=>e=l(Error(i+" could not load.")),s.nonce=this.nonce||(null===(d=h.querySelector("script[nonce]"))||void 0===d?void 0:d.nonce)||"",h.head.append(s)},new((g=void 0)||(g=Promise))(function(t,e){function s(t){try{i(f.next(t))}catch(p){e(p)}}function r(t){try{i(f.throw(t))}catch(p){e(p)}}function i(e){var i;e.done?t(e.value):(i=e.value,i instanceof g?i:new g(function(t){t(i)})).then(s,r)}i((f=f.apply(d,m||[])).next())});var d,m,g,f}));c[n]?console.warn(i+" only loads once. Ignoring:",t):c[n]=(t,...e)=>u.add(t)&&d().then(()=>c[n](t,...e))})(s);const r=this.libraries.map(t=>this.importLibrary(t));r.length||r.push(this.importLibrary("core")),Promise.all(r).then(()=>this.callback(),t=>{const e=new ErrorEvent("error",{error:t});this.loadErrorCallback(e)})}reset(){this.deleteScript(),this.done=!1,this.loading=!1,this.errors=[],this.onerrorEvent=null}resetIfRetryingFailed(){this.failed&&this.reset()}loadErrorCallback(t){if(this.errors.push(t),this.errors.length<=this.retries){const t=this.errors.length*Math.pow(2,this.errors.length);console.error(`Failed to load Google Maps script, retrying in ${t} ms.`),setTimeout(()=>{this.deleteScript(),this.setScript()},t)}else this.onerrorEvent=t,this.callback()}callback(){this.done=!0,this.loading=!1,this.callbacks.forEach(t=>{t(this.onerrorEvent)}),this.callbacks=[]}execute(){if(this.resetIfRetryingFailed(),!this.loading)if(this.done)this.callback();else{if(window.google&&window.google.maps&&window.google.maps.version)return console.warn("Google Maps already loaded outside @googlemaps/js-api-loader. This may result in undesirable behavior as options and script parameters may not match."),void this.callback();this.loading=!0,this.setScript()}}}const l=Object.freeze(Object.defineProperty({__proto__:null,DEFAULT_ID:o,Loader:h,get LoaderStatus(){return n}},Symbol.toStringTag,{value:"Module"})),c=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class u{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,s]=new Uint8Array(t,0,2);if(219!==e)throw new Error("Data does not appear to be in a KDBush format.");const r=s>>4;if(1!==r)throw new Error(`Got v${r} data when expected v1.`);const i=c[15&s];if(!i)throw new Error("Unrecognized array type.");const[o]=new Uint16Array(t,2,1),[n]=new Uint32Array(t,4,1);return new u(n,o,i,t)}constructor(t,e=64,s=Float64Array,r){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=s,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const i=c.indexOf(this.ArrayType),o=2*t*this.ArrayType.BYTES_PER_ELEMENT,n=t*this.IndexArrayType.BYTES_PER_ELEMENT,a=(8-n%8)%8;if(i<0)throw new Error(`Unexpected typed array class: ${s}.`);r&&r instanceof ArrayBuffer?(this.data=r,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+n+a,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+o+n+a),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+n+a,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+i]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return p(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:o,nodeSize:n}=this,a=[0,i.length-1,0],h=[];for(;a.length;){const l=a.pop()||0,c=a.pop()||0,u=a.pop()||0;if(c-u<=n){for(let n=u;n<=c;n++){const a=o[2*n],l=o[2*n+1];a>=t&&a<=s&&l>=e&&l<=r&&h.push(i[n])}continue}const p=u+c>>1,d=o[2*p],m=o[2*p+1];d>=t&&d<=s&&m>=e&&m<=r&&h.push(i[p]),(0===l?t<=d:e<=m)&&(a.push(u),a.push(p-1),a.push(1-l)),(0===l?s>=d:r>=m)&&(a.push(p+1),a.push(c),a.push(1-l))}return h}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:r,coords:i,nodeSize:o}=this,n=[0,r.length-1,0],a=[],h=s*s;for(;n.length;){const l=n.pop()||0,c=n.pop()||0,u=n.pop()||0;if(c-u<=o){for(let s=u;s<=c;s++)f(i[2*s],i[2*s+1],t,e)<=h&&a.push(r[s]);continue}const p=u+c>>1,d=i[2*p],m=i[2*p+1];f(d,m,t,e)<=h&&a.push(r[p]),(0===l?t-s<=d:e-s<=m)&&(n.push(u),n.push(p-1),n.push(1-l)),(0===l?t+s>=d:e+s>=m)&&(n.push(p+1),n.push(c),n.push(1-l))}return a}}function p(t,e,s,r,i,o){if(i-r<=s)return;const n=r+i>>1;d(t,e,n,r,i,o),p(t,e,s,r,n-1,1-o),p(t,e,s,n+1,i,1-o)}function d(t,e,s,r,i,o){for(;i>r;){if(i-r>600){const n=i-r+1,a=s-r+1,h=Math.log(n),l=.5*Math.exp(2*h/3),c=.5*Math.sqrt(h*l*(n-l)/n)*(a-n/2<0?-1:1);d(t,e,s,Math.max(r,Math.floor(s-a*l/n+c)),Math.min(i,Math.floor(s+(n-a)*l/n+c)),o)}const n=e[2*s+o];let a=r,h=i;for(m(t,e,r,s),e[2*i+o]>n&&m(t,e,r,i);a<h;){for(m(t,e,a,h),a++,h--;e[2*a+o]<n;)a++;for(;e[2*h+o]>n;)h--}e[2*r+o]===n?m(t,e,r,h):(h++,m(t,e,h,i)),h<=s&&(r=h+1),s<=h&&(i=h-1)}}function m(t,e,s,r){g(t,s,r),g(e,2*s,2*r),g(e,2*s+1,2*r+1)}function g(t,e,s){const r=t[e];t[e]=t[s],t[s]=r}function f(t,e,s,r){const i=t-s,o=e-r;return i*i+o*o}const y={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},w=Math.fround||(t=>e=>(t[0]=+e,t[0]))(new Float32Array(1));class k{constructor(t){this.options=Object.assign(Object.create(y),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:s,maxZoom:r}=this.options;e&&console.time("total time");const i=`prepare ${t.length} points`;e&&console.time(i),this.points=t;const o=[];for(let a=0;a<t.length;a++){const e=t[a];if(!e.geometry)continue;const[s,r]=e.geometry.coordinates,i=w(b(s)),n=w(x(r));o.push(i,n,1/0,a,-1,1),this.options.reduce&&o.push(0)}let n=this.trees[r+1]=this._createTree(o);e&&console.timeEnd(i);for(let a=r;a>=s;a--){const t=+Date.now();n=this.trees[a]=this._createTree(this._cluster(n,a)),e&&console.log("z%d: %d clusters in %dms",a,n.numItems,+Date.now()-t)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,t[1]));let i=180===t[2]?180:((t[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,i=180;else if(s>i){const t=this.getClusters([s,r,180,o],e),n=this.getClusters([-180,r,i,o],e);return t.concat(n)}const n=this.trees[this._limitZoom(e)],a=n.range(b(s),x(o),b(i),x(r)),h=n.data,l=[];for(const c of a){const t=this.stride*c;l.push(h[t+5]>1?v(h,t,this.clusterProps):this.points[h[t+3]])}return l}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),r="No cluster with the specified id.",i=this.trees[s];if(!i)throw new Error(r);const o=i.data;if(e*this.stride>=o.length)throw new Error(r);const n=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=o[e*this.stride],h=o[e*this.stride+1],l=i.within(a,h,n),c=[];for(const u of l){const e=u*this.stride;o[e+4]===t&&c.push(o[e+5]>1?v(o,e,this.clusterProps):this.points[o[e+3]])}if(0===c.length)throw new Error(r);return c}getLeaves(t,e,s){e=e||10,s=s||0;const r=[];return this._appendLeaves(r,t,e,s,0),r}getTile(t,e,s){const r=this.trees[this._limitZoom(t)],i=Math.pow(2,t),{extent:o,radius:n}=this.options,a=n/o,h=(s-a)/i,l=(s+1+a)/i,c={features:[]};return this._addTileFeatures(r.range((e-a)/i,h,(e+1+a)/i,l),r.data,e,s,i,c),0===e&&this._addTileFeatures(r.range(1-a/i,h,1,l),r.data,i,s,i,c),e===i-1&&this._addTileFeatures(r.range(0,h,a/i,l),r.data,-1,s,i,c),c.features.length?c:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,1!==s.length)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,r,i){const o=this.getChildren(e);for(const n of o){const e=n.properties;if(e&&e.cluster?i+e.point_count<=r?i+=e.point_count:i=this._appendLeaves(t,e.cluster_id,s,r,i):i<r?i++:t.push(n),t.length===s)break}return i}_createTree(t){const e=new u(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<t.length;s+=this.stride)e.add(t[s],t[s+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,s,r,i,o){for(const n of t){const t=n*this.stride,a=e[t+5]>1;let h,l,c;if(a)h=M(e,t,this.clusterProps),l=e[t],c=e[t+1];else{const s=this.points[e[t+3]];h=s.properties;const[r,i]=s.geometry.coordinates;l=b(r),c=x(i)}const u={type:1,geometry:[[Math.round(this.options.extent*(l*i-s)),Math.round(this.options.extent*(c*i-r))]],tags:h};let p;p=a||this.options.generateId?e[t+3]:this.points[e[t+3]].id,void 0!==p&&(u.id=p),o.features.push(u)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:r,reduce:i,minPoints:o}=this.options,n=s/(r*Math.pow(2,e)),a=t.data,h=[],l=this.stride;for(let c=0;c<a.length;c+=l){if(a[c+2]<=e)continue;a[c+2]=e;const s=a[c],r=a[c+1],u=t.within(a[c],a[c+1],n),p=a[c+5];let d=p;for(const t of u){const s=t*l;a[s+2]>e&&(d+=a[s+5])}if(d>p&&d>=o){let t,o=s*p,n=r*p,m=-1;const g=(c/l<<5)+(e+1)+this.points.length;for(const s of u){const r=s*l;if(a[r+2]<=e)continue;a[r+2]=e;const h=a[r+5];o+=a[r]*h,n+=a[r+1]*h,a[r+4]=g,i&&(t||(t=this._map(a,c,!0),m=this.clusterProps.length,this.clusterProps.push(t)),i(t,this._map(a,r)))}a[c+4]=g,h.push(o/d,n/d,1/0,g,-1,d),i&&h.push(m)}else{for(let t=0;t<l;t++)h.push(a[c+t]);if(d>1)for(const t of u){const s=t*l;if(!(a[s+2]<=e)){a[s+2]=e;for(let t=0;t<l;t++)h.push(a[s+t])}}}}return h}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+5]>1){const r=this.clusterProps[t[e+6]];return s?Object.assign({},r):r}const r=this.points[t[e+3]].properties,i=this.options.map(r);return s&&i===r?Object.assign({},i):i}}function v(t,e,s){return{type:"Feature",id:t[e+3],properties:M(t,e,s),geometry:{type:"Point",coordinates:[(r=t[e],360*(r-.5)),P(t[e+1])]}};var r}function M(t,e,s){const r=t[e+5],i=r>=1e4?`${Math.round(r/1e3)}k`:r>=1e3?Math.round(r/100)/10+"k":r,o=t[e+6],n=-1===o?{}:Object.assign({},s[o]);return Object.assign(n,{cluster:!0,cluster_id:t[e+3],point_count:r,point_count_abbreviated:i})}function b(t){return t/360+.5}function x(t){const e=Math.sin(t*Math.PI/180),s=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return s<0?0:s>1?1:s}function P(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function E(t,e){var s={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(s[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(s[r[i]]=t[r[i]])}return s}class _{static isAdvancedMarkerAvailable(t){return google.maps.marker&&!0===t.getMapCapabilities().isAdvancedMarkersAvailable}static isAdvancedMarker(t){return google.maps.marker&&t instanceof google.maps.marker.AdvancedMarkerElement}static setMap(t,e){this.isAdvancedMarker(t)?t.map=e:t.setMap(e)}static getPosition(t){if(this.isAdvancedMarker(t)){if(t.position){if(t.position instanceof google.maps.LatLng)return t.position;if(t.position.lat&&t.position.lng)return new google.maps.LatLng(t.position.lat,t.position.lng)}return new google.maps.LatLng(null)}return t.getPosition()}static getVisible(t){return!!this.isAdvancedMarker(t)||t.getVisible()}}class C{constructor({markers:t,position:e}){this.markers=t,e&&(e instanceof google.maps.LatLng?this._position=e:this._position=new google.maps.LatLng(e))}get bounds(){if(0===this.markers.length&&!this._position)return;const t=new google.maps.LatLngBounds(this._position,this._position);for(const e of this.markers)t.extend(_.getPosition(e));return t}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter(t=>_.getVisible(t)).length}push(t){this.markers.push(t)}delete(){this.marker&&(_.setMap(this.marker,null),this.marker=void 0),this.markers.length=0}}const A=(t,e,s,r)=>{const i=I(t.getBounds(),e,r);return s.filter(t=>i.contains(_.getPosition(t)))},I=(t,e,s)=>{const{northEast:r,southWest:i}=O(t,e),o=T({northEast:r,southWest:i},s);return Z(o,e)},L=(t,e,s)=>{const r=I(t,e,s),i=r.getNorthEast(),o=r.getSouthWest();return[o.lng(),o.lat(),i.lng(),i.lat()]},S=(t,e)=>{const s=(e.lat-t.lat)*Math.PI/180,r=(e.lng-t.lng)*Math.PI/180,i=Math.sin(s/2),o=Math.sin(r/2),n=i*i+Math.cos(t.lat*Math.PI/180)*Math.cos(e.lat*Math.PI/180)*o*o;return 2*Math.atan2(Math.sqrt(n),Math.sqrt(1-n))*6371},O=(t,e)=>({northEast:e.fromLatLngToDivPixel(t.getNorthEast()),southWest:e.fromLatLngToDivPixel(t.getSouthWest())}),T=({northEast:t,southWest:e},s)=>(t.x+=s,t.y-=s,e.x-=s,e.y+=s,{northEast:t,southWest:e}),Z=({northEast:t,southWest:e},s)=>{const r=s.fromDivPixelToLatLng(e),i=s.fromDivPixelToLatLng(t);return new google.maps.LatLngBounds(r,i)};class j{constructor({maxZoom:t=16}){this.maxZoom=t}noop({markers:t}){return z(t)}}class U extends j{constructor(t){var{viewportPadding:e=60}=t;super(E(t,["viewportPadding"])),this.viewportPadding=60,this.viewportPadding=e}calculate({markers:t,map:e,mapCanvasProjection:s}){return e.getZoom()>=this.maxZoom?{clusters:this.noop({markers:t}),changed:!1}:{clusters:this.cluster({markers:A(e,s,t,this.viewportPadding),map:e,mapCanvasProjection:s})}}}const z=t=>t.map(t=>new C({position:_.getPosition(t),markers:[t]}));class D extends j{constructor(t){var{maxZoom:e,radius:s=60}=t,r=E(t,["maxZoom","radius"]);super({maxZoom:e}),this.state={zoom:-1},this.superCluster=new k(Object.assign({maxZoom:this.maxZoom,radius:s},r))}calculate(e){let s=!1;const r={zoom:e.map.getZoom()};if(!t(e.markers,this.markers)){s=!0,this.markers=[...e.markers];const t=this.markers.map(t=>{const e=_.getPosition(t);return{type:"Feature",geometry:{type:"Point",coordinates:[e.lng(),e.lat()]},properties:{marker:t}}});this.superCluster.load(t)}return s||(this.state.zoom<=this.maxZoom||r.zoom<=this.maxZoom)&&(s=!t(this.state,r)),this.state=r,s&&(this.clusters=this.cluster(e)),{clusters:this.clusters,changed:s}}cluster({map:t}){return this.superCluster.getClusters([-180,-90,180,90],Math.round(t.getZoom())).map(t=>this.transformCluster(t))}transformCluster({geometry:{coordinates:[t,e]},properties:s}){if(s.cluster)return new C({markers:this.superCluster.getLeaves(s.cluster_id,1/0).map(t=>t.properties.marker),position:{lat:e,lng:t}});const r=s.marker;return new C({markers:[r],position:_.getPosition(r)})}}class N{constructor(t,e){this.markers={sum:t.length};const s=e.map(t=>t.count),r=s.reduce((t,e)=>t+e,0);this.clusters={count:e.length,markers:{mean:r/e.length,sum:r,min:Math.min(...s),max:Math.max(...s)}}}}class R{render({count:t,position:e},s,r){const i=`<svg fill="${t>Math.max(10,s.clusters.markers.mean)?"#ff0000":"#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">\n<circle cx="120" cy="120" opacity=".6" r="70" />\n<circle cx="120" cy="120" opacity=".3" r="90" />\n<circle cx="120" cy="120" opacity=".2" r="110" />\n<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>\n</svg>`,o=`Cluster of ${t} markers`,n=Number(google.maps.Marker.MAX_ZINDEX)+t;if(_.isAdvancedMarkerAvailable(r)){const t=(new DOMParser).parseFromString(i,"image/svg+xml").documentElement;t.setAttribute("transform","translate(0 25)");const s={map:r,position:e,zIndex:n,title:o,content:t};return new google.maps.marker.AdvancedMarkerElement(s)}const a={position:e,zIndex:n,title:o,icon:{url:`data:image/svg+xml;base64,${btoa(i)}`,anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(a)}}class B{constructor(){!function(t,e){for(let s in e.prototype)t.prototype[s]=e.prototype[s]}(B,google.maps.OverlayView)}}var $,F;(F=$||($={})).CLUSTERING_BEGIN="clusteringbegin",F.CLUSTERING_END="clusteringend",F.CLUSTER_CLICK="click";const G=(t,e,s)=>{s.fitBounds(e.bounds)},K=Object.freeze(Object.defineProperty({__proto__:null,AbstractAlgorithm:j,AbstractViewportAlgorithm:U,Cluster:C,ClusterStats:N,DefaultRenderer:R,GridAlgorithm:class extends U{constructor(t){var{maxDistance:e=4e4,gridSize:s=40}=t;super(E(t,["maxDistance","gridSize"])),this.clusters=[],this.state={zoom:-1},this.maxDistance=e,this.gridSize=s}calculate({markers:e,map:s,mapCanvasProjection:r}){const i={zoom:s.getZoom()};let o=!1;return this.state.zoom>=this.maxZoom&&i.zoom>=this.maxZoom||(o=!t(this.state,i)),this.state=i,s.getZoom()>=this.maxZoom?{clusters:this.noop({markers:e}),changed:o}:{clusters:this.cluster({markers:A(s,r,e,this.viewportPadding),map:s,mapCanvasProjection:r})}}cluster({markers:t,map:e,mapCanvasProjection:s}){return this.clusters=[],t.forEach(t=>{this.addToClosestCluster(t,e,s)}),this.clusters}addToClosestCluster(t,e,s){let r=this.maxDistance,i=null;for(let o=0;o<this.clusters.length;o++){const e=this.clusters[o],s=S(e.bounds.getCenter().toJSON(),_.getPosition(t).toJSON());s<r&&(r=s,i=e)}if(i&&I(i.bounds,s,this.gridSize).contains(_.getPosition(t)))i.push(t);else{const e=new C({markers:[t]});this.clusters.push(e)}}},MarkerClusterer:class extends B{constructor({map:t,markers:e=[],algorithmOptions:s={},algorithm:r=new D(s),renderer:i=new R,onClusterClick:o=G}){super(),this.markers=[...e],this.clusters=[],this.algorithm=r,this.renderer=i,this.onClusterClick=o,t&&this.setMap(t)}addMarker(t,e){this.markers.includes(t)||(this.markers.push(t),e||this.render())}addMarkers(t,e){t.forEach(t=>{this.addMarker(t,!0)}),e||this.render()}removeMarker(t,e){const s=this.markers.indexOf(t);return-1!==s&&(_.setMap(t,null),this.markers.splice(s,1),e||this.render(),!0)}removeMarkers(t,e){let s=!1;return t.forEach(t=>{s=this.removeMarker(t,!0)||s}),s&&!e&&this.render(),s}clearMarkers(t){this.markers.length=0,t||this.render()}render(){const t=this.getMap();if(t instanceof google.maps.Map&&t.getProjection()){google.maps.event.trigger(this,$.CLUSTERING_BEGIN,this);const{clusters:e,changed:s}=this.algorithm.calculate({markers:this.markers,map:t,mapCanvasProjection:this.getProjection()});if(s||null==s){const t=new Set;for(const r of e)1==r.markers.length&&t.add(r.markers[0]);const s=[];for(const e of this.clusters)null!=e.marker&&(1==e.markers.length?t.has(e.marker)||_.setMap(e.marker,null):s.push(e.marker));this.clusters=e,this.renderClusters(),requestAnimationFrame(()=>s.forEach(t=>_.setMap(t,null)))}google.maps.event.trigger(this,$.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this)),this.render()}onRemove(){google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach(t=>_.setMap(t,null)),this.clusters.forEach(t=>t.delete()),this.clusters=[]}renderClusters(){const t=new N(this.markers,this.clusters),e=this.getMap();this.clusters.forEach(s=>{1===s.markers.length?s.marker=s.markers[0]:(s.marker=this.renderer.render(s,t,e),s.markers.forEach(t=>_.setMap(t,null)),this.onClusterClick&&s.marker.addListener("click",t=>{google.maps.event.trigger(this,$.CLUSTER_CLICK,s),this.onClusterClick(t,s,e)})),_.setMap(s.marker,e)})}},get MarkerClustererEvents(){return $},MarkerUtils:_,NoopAlgorithm:class extends j{constructor(t){super(E(t,[]))}calculate({markers:t,map:e,mapCanvasProjection:s}){return{clusters:this.cluster({markers:t,map:e,mapCanvasProjection:s}),changed:!1}}cluster(t){return this.noop(t)}},SuperClusterAlgorithm:D,SuperClusterViewportAlgorithm:class extends U{constructor(t){var{maxZoom:e,radius:s=60,viewportPadding:r=60}=t,i=E(t,["maxZoom","radius","viewportPadding"]);super({maxZoom:e,viewportPadding:r}),this.superCluster=new k(Object.assign({maxZoom:this.maxZoom,radius:s},i)),this.state={zoom:-1,view:[0,0,0,0]}}calculate(e){const s={zoom:Math.round(e.map.getZoom()),view:L(e.map.getBounds(),e.mapCanvasProjection,this.viewportPadding)};let r=!t(this.state,s);if(!t(e.markers,this.markers)){r=!0,this.markers=[...e.markers];const t=this.markers.map(t=>{const e=_.getPosition(t);return{type:"Feature",geometry:{type:"Point",coordinates:[e.lng(),e.lat()]},properties:{marker:t}}});this.superCluster.load(t)}return r&&(this.clusters=this.cluster(e),this.state=s),{clusters:this.clusters,changed:r}}cluster({map:t,mapCanvasProjection:e}){const s={zoom:Math.round(t.getZoom()),view:L(t.getBounds(),e,this.viewportPadding)};return this.superCluster.getClusters(s.view,s.zoom).map(t=>this.transformCluster(t))}transformCluster({geometry:{coordinates:[t,e]},properties:s}){if(s.cluster)return new C({markers:this.superCluster.getLeaves(s.cluster_id,1/0).map(t=>t.properties.marker),position:{lat:e,lng:t}});const r=s.marker;return new C({markers:[r],position:_.getPosition(r)})}},defaultOnClusterClickHandler:G,distanceBetweenPoints:S,extendBoundsToPaddedViewport:I,extendPixelBounds:T,filterMarkersToPaddedViewport:A,getPaddedViewport:L,noop:z,pixelBoundsToLatLngBounds:Z},Symbol.toStringTag,{value:"Module"}));export{K as a,l as i};
